// +build ignore

package main

import (
	"bytes"
	"encoding/csv"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"time"
)

const url = "https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.csv"

var filename = flag.String("output", "data.go", "output filename")

func main() {
	flag.Parse()
	t := template.Must(template.New("program").Parse(program))
	ss, err := fetch()
	if err != nil {
		log.Fatal(err)
	}
	err = write(*filename, t, ss)
	if err != nil {
		log.Fatal(err)
	}
}

type service struct {
	Name  string
	Desc  string
	ports []string
}

func (s service) Ports() string {
	ps := make([]string, len(s.ports))
	for i, p := range s.ports {
		ps[i] = fmt.Sprintf("%q", p)
	}
	return fmt.Sprintf("[]string{%s}", strings.Join(ps, ", "))
}

type services []*service

func (ss services) Len() int           { return len(ss) }
func (ss services) Less(i, j int) bool { return ss[i].Name < ss[j].Name }
func (ss services) Swap(i, j int)      { ss[i], ss[j] = ss[j], ss[i] }

func fetch() (services, error) {
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	return parse(resp.Body)
}

func parse(r io.Reader) (services, error) {
	f := csv.NewReader(r)
	m := make(map[string]*service)
	_, err := f.Read() // Skip the header.
	if err != nil {
		return nil, err
	}
	for {
		row, err := f.Read()
		if err != nil {
			if err != io.EOF {
				return nil, err
			}
			break
		}
		name := row[0]
		if name == "" {
			continue
		}
		if strings.Contains(row[11], "historic") {
			continue
		}
		ports, err := getPorts(row[1])
		if err != nil {
			if err != errNoPorts {
				log.Println(err)
			}
			continue
		}
		protocol := row[2]
		s, ok := m[name]
		if ok {
			for _, port := range ports {
				s.ports = append(s.ports, port+"/"+protocol)
			}
			continue
		}
		s = &service{
			Name: name,
			Desc: strings.Replace(row[3], "\n", " ", -1),
		}
		for _, port := range ports {
			if protocol == "" {
				s.ports = append(s.ports, port)
			} else {
				s.ports = append(s.ports, port+"/"+protocol)
			}
			m[name] = s
		}
	}
	ss := make(services, 0)
	for _, s := range m {
		ss = append(ss, s)
	}
	sort.Sort(ss)
	return ss, nil
}

var errNoPorts = errors.New("snpn: no ports")

func getPorts(s string) ([]string, error) {
	if s == "" {
		return nil, errNoPorts
	}
	i := strings.Index(s, "-")
	if i == -1 {
		return []string{s}, nil
	}
	a, err := strconv.Atoi(s[:i])
	if err != nil {
		return nil, err
	}
	b, err := strconv.Atoi(s[i+1:])
	if err != nil {
		return nil, err
	}
	var ports []string
	for i := a; i <= b; i++ {
		ports = append(ports, strconv.Itoa(i))
	}
	return ports, nil
}

func write(filename string, t *template.Template, ss services) error {
	var buf bytes.Buffer
	v := struct {
		URL      string
		Services services
	}{
		URL:      url,
		Services: ss,
	}
	err := t.Execute(&buf, v)
	if err != nil {
		return err
	}
	data, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return ioutil.WriteFile(filename, data, 0644)
}

const program = `
// generated by gendata.go from
// {{.URL}}

package snpn

var services = map[string]Service{
{{range .Services}}	"{{.Name}}": {"{{.Name}}", {{.Ports}}, {{.Desc | printf "%#q"}}},
{{end}}
}
`
